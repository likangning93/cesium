<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Point Cloud Attenuation and Eye Dome Lighting example.">
    <meta name="cesium-sandcastle-labels" content="3D Tiles">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script>
    <script type="text/javascript">
        if(typeof require === "function") {
            require.config({
                baseUrl : '../../../Source',
                waitSeconds : 120
            });
        }
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);
    #toolbar {
        background: rgba(42, 42, 42, 0.8);
        padding: 4px;
        border-radius: 4px;
    }
    #toolbar input {
        vertical-align: middle;
        padding-top: 2px;
        padding-bottom: 2px;
    }
    #toolbar .header {
        font-weight: bold;
    }
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar">
    <table><tbody>
    <tr>
        <td>Maximum Screen Space Error</td>
        <td>
            <input type="range" min="0.0" max="64.0" step="0.1" data-bind="value: maximumScreenSpaceError, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: maximumScreenSpaceError">
        </td>
    </tr>
    <tr><td class="header">Attenuation</td></tr>
    <tr>
        <td>Geometric Error Scale</td>
        <td>
            <input type="range" min="0.0" max="2.0" step="0.1" data-bind="value: geometricErrorScale, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: geometricErrorScale">
        </td>
    </tr>
    <tr>
        <td>Maximum Attenuation</td>
        <td>
            <input type="range" min="0.0" max="64.0" step="1.0" data-bind="value: maximumAttenuation, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: maximumAttenuation">
        </td>
    </tr>
    <tr>
        <td>Base Resolution</td>
        <td>
            <input type="range" min="0.0" max="10.0" step="0.01" data-bind="value: baseResolution, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: baseResolution">
        </td>
    </tr>
    <tr><td class="header">Eye Dome Lighting</td></tr>
    <tr>
        <td>Eye Dome Lighting Strength</td>
        <td>
            <input type="range" min="0.0" max="10.0" step="0.1" data-bind="value: eyeDomeLightingStrength, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: eyeDomeLightingStrength">
        </td>
    </tr>
    <tr>
        <td>Eye Dome Lighting Radius</td>
        <td>
            <input type="range" min="0.0" max="10.0" step="0.1" data-bind="value: eyeDomeLightingRadius, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: eyeDomeLightingRadius">
        </td>
    </tr>
    </tbody></table>
</div>
<script id="cesium_sandcastle_script">
function startup(Cesium) {
    'use strict';
//Sandcastle_Begin
var viewer = new Cesium.Viewer('cesiumContainer', {
    //baseLayerPicker : false
});
// tiles inspector stuff
//viewer.extend(Cesium.viewerCesium3DTilesInspectorMixin);
//var inspectorViewModel = viewer.cesium3DTilesInspector.viewModel;
// end tiles inspector stuff

var scene = viewer.scene;

// Mt. St. Helens 3D Tileset generated from LAS provided by https://www.liblas.org/samples/
var url = 'http://localhost:8002/tilesets/NYU_Dublin/';
var tileset = scene.primitives.add(new Cesium.Cesium3DTileset({
    url : url
}));

tileset.readyPromise.then(function() {
    tileset.maximumScreenSpaceError = 32.0;
    tileset.pointShading.geometricErrorAttenuation = true;
    tileset.pointShading.eyeDomeLighting = true;
    tileset.pointShading.maximumAttenuation = 8.0;
    setStyle(tileset);

    var boundingSphere = tileset.boundingSphere;
    var range = Math.max(100.0 - boundingSphere.radius, 0.0); // Set a minimum offset of 100 meters
    viewer.camera.viewBoundingSphere(boundingSphere, new Cesium.HeadingPitchRange(0, -2.0, range));
    viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
});

function getEarthRadius(tileset) {
    var cartographic = Cesium.Cartographic.fromCartesian(tileset.boundingSphere.center);
    var cartesian = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude);
    return Cesium.Cartesian3.magnitude(cartesian);
}

function setStyle(tileset) {
    var radius = getEarthRadius(tileset);
    tileset.style = new Cesium.Cesium3DTileStyle({
        defines : {
            height : 'length(${POSITION_ABSOLUTE}) - ' + radius
        },
        color : 'mix(vec4(210, 194, 183, 255)/255.0, vec4(51, 61, 30, 255)/255, clamp(${height} / 70.0, 0.0, 1.0))',
        show : '0 < ${height} && ${height} < 130'
    });
}

// The viewModel tracks the state of our mini application.
var viewModel = {
    maximumScreenSpaceError : 32.0,
    geometricErrorScale : 1.0,
    maximumAttenuation : 8.0,
    baseResolution : 0, // Equivalent to undefined
    eyeDomeLightingStrength : 1.0,
    eyeDomeLightingRadius : 1.0,
    picking : false
};

function checkZero(newValue) {
    var newValueFloat = parseFloat(newValue);
    return (newValueFloat === 0.0) ? undefined : newValueFloat;
}

// Convert the viewModel members into knockout observables.
Cesium.knockout.track(viewModel);

// Bind the viewModel to the DOM elements of the UI that call for it.
var toolbar = document.getElementById('toolbar');
Cesium.knockout.applyBindings(viewModel, toolbar);

Cesium.knockout.getObservable(viewModel, 'maximumScreenSpaceError').subscribe(
    function(newValue) {
        tileset.maximumScreenSpaceError = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'geometricErrorScale').subscribe(
    function(newValue) {
        tileset.pointShading.geometricErrorScale = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'maximumAttenuation').subscribe(
    function(newValue) {
        tileset.pointShading.maximumAttenuation = checkZero(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'baseResolution').subscribe(
    function(newValue) {
        tileset.pointShading.baseResolution = checkZero(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'eyeDomeLightingStrength').subscribe(
    function(newValue) {
        tileset.pointShading.eyeDomeLightingStrength = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'eyeDomeLightingRadius').subscribe(
    function(newValue) {
        tileset.pointShading.eyeDomeLightingRadius = parseFloat(newValue);
    }
);
/*
Sandcastle.addToggleButton('Enable Attenuation', true, function(checked) {
    tileset.pointShading.geometricErrorAttenuation = checked;
});

Sandcastle.addToggleButton('Enable Eye Dome Lighting', true, function(checked) {
    tileset.pointShading.eyeDomeLighting = checked;
});
*/
var labelEntity = viewer.entities.add({
    label : {
        show : false,
        showBackground : true,
        font : '14px monospace',
        horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
        verticalOrigin : Cesium.VerticalOrigin.TOP,
        pixelOffset : new Cesium.Cartesian2(15, 0)
    }
});
/*
Sandcastle.addToggleButton('Pick Position', false, function(checked) {
    viewModel.picking = checked;
    labelEntity.label.show = checked;
});


// Mouse over the globe to see the cartographic position
var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
handler.setInputAction(function(movement) {
    if (!viewModel.picking) {
        return;
    }

    var foundPosition = false;

    var scene = viewer.scene;
    if (scene.mode !== Cesium.SceneMode.MORPHING) {
        var pickedObject = scene.pick(movement.endPosition);
        if (scene.pickPositionSupported && Cesium.defined(pickedObject)) {
            var cartesian = viewer.scene.pickPosition(movement.endPosition);

            if (Cesium.defined(cartesian)) {

                var cartographic = Cesium.Cartographic.fromCartesian(cartesian);

                labelEntity.label.text =
                    'x: ' + ('   ' + cartesian.x).slice(-16) +
                    '\ny: ' + ('   ' + cartesian.y).slice(-16) +
                    '\nz: ' + ('   ' + cartesian.z).slice(-16);

                labelEntity.label.show = true;
                labelEntity.position = cartesian;
                labelEntity.label.eyeOffset = new Cesium.Cartesian3(0.0, 0.0, -cartographic.height * (scene.mode === Cesium.SceneMode.SCENE2D ? 1.5 : 2.5));

                foundPosition = true;
            }
        }
    }

    if (!foundPosition) {
        labelEntity.label.show = false;
    }
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
*/
/** begin czml path generator **/
var Cartesian2 = Cesium.Cartesian2;
var Cartesian3 = Cesium.Cartesian3;
var CesiumMath = Cesium.Math;
var Color = Cesium.Color;
var defined = Cesium.defined;
var LabelCollection = Cesium.LabelCollection;
var Matrix3 = Cesium.Matrix3;
var PointPrimitiveCollection = Cesium.PointPrimitiveCollection;
var Quaternion = Cesium.Quaternion;
var VerticalOrigin = Cesium.VerticalOrigin;
var HorizontalOrigin = Cesium.HorizontalOrigin;

// some state
var pointCollection = scene.primitives.add(new PointPrimitiveCollection());
var labelCollection = scene.primitives.add(new LabelCollection());
var adjustingTime = false;
var adjustingWait = false;
var leftDown = false;

var selectedWaypoint;
var waypoints = JSON.parse('[{"position":{"x":3792984.7523233113,"y":-415626.7786524582,"z":5093751.383848479},"wait":0,"time":0},{"position":{"x":3792981.062763432,"y":-415654.67900809395,"z":5093751.83982436},"wait":0,"time":0},{"position":{"x":3792981.3366281744,"y":-415656.83770198154,"z":5093751.458806289},"wait":0,"time":0},{"position":{"x":3792982.5365218935,"y":-415657.8208687477,"z":5093750.4887058595},"wait":0,"time":0},{"position":{"x":3792983.993834728,"y":-415658.0509285248,"z":5093749.397371495},"wait":0,"time":0},{"position":{"x":3792997.7565851854,"y":-415659.70130747685,"z":5093739.0809932295},"wait":0,"time":0},{"position":{"x":3792999.425561976,"y":-415658.5349806993,"z":5093737.953246055},"wait":0,"time":0},{"position":{"x":3793000.498116694,"y":-415656.52468040993,"z":5093737.318804108},"wait":0,"time":0},{"position":{"x":3793000.8282486666,"y":-415654.00737613894,"z":5093737.271097338},"wait":0,"time":0},{"position":{"x":3793005.0343612973,"y":-415626.0093012121,"z":5093736.414492959},"wait":0,"time":0},{"position":{"x":3793005.106974686,"y":-415624.39130692586,"z":5093736.519209336},"wait":0,"time":0},{"position":{"x":3793004.3157176822,"y":-415622.81746385904,"z":5093737.243058044},"wait":0,"time":0},{"position":{"x":3793001.6612716694,"y":-415622.25268397474,"z":5093739.293390674},"wait":0,"time":0},{"position":{"x":3792987.955080579,"y":-415620.3810242807,"z":5093749.520317478},"wait":0,"time":0},{"position":{"x":3792986.438148425,"y":-415620.7110075121,"z":5093750.613837062},"wait":0,"time":0},{"position":{"x":3792985.4862400983,"y":-415622.1696023137,"z":5093751.208983416},"wait":0,"time":0},{"position":{"x":3792984.7412657687,"y":-415624.7825034844,"z":5093751.541839033},"wait":0,"time":9.993055555555555}]');
updateGraphics();

function Waypoint(position) {
    this.position = Cartesian3.clone(position);
    this.wait = 0.0;
    this.time = 0.0;
}

var leftClickHandler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
leftClickHandler.setInputAction(function(movement) {
    var scene = viewer.scene;
    if (scene.mode !== Cesium.SceneMode.MORPHING) {
        // picking
        if (!adjustingTime && !adjustingWait) {
            var pickedObject = scene.pick(movement.position);
            if (scene.pickPositionSupported && Cesium.defined(pickedObject)) {
                var cartesian = viewer.scene.pickPosition(movement.position);
                if (Cesium.defined(cartesian)) {
                   handlePick(cartesian);
                }
            }
        }
        updateGraphics();
    }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);

var moveHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
moveHandler.setInputAction(function(movement) {
    if (leftDown) {
        if (adjustingTime && defined(selectedWaypoint)) {
            var width = scene.context.drawingBufferWidth;

            selectedWaypoint.time = movement.endPosition.x / width * 10;
        }
        if (adjustingWait && defined(selectedWaypoint)) {
            var height = scene.context.drawingBufferHeight;

            selectedWaypoint.wait = (movement.endPosition.y / height) * 10;
        }
        if ((adjustingWait || adjustingTime) && defined(selectedWaypoint)) {
            updateGraphics();
        }
    }
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

var downHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
downHandler.setInputAction(function(movement) {
    leftDown = true;
}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

var upHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
upHandler.setInputAction(function(movement) {
    leftDown = false;
}, Cesium.ScreenSpaceEventType.LEFT_UP);

function updateGraphics() {
    // update point collection
    var waypointCount = waypoints.length;
    pointCollection.removeAll();
    labelCollection.removeAll();
    for (var i = 0 ; i < waypointCount; i++) {
        var waypoint = waypoints[i];
        var labelText = '';
        if (waypoint.time > 0.0) {
            labelText += ('time: ' + waypoint.time).slice(0, 10);
        }
        if (waypoint.wait > 0.0) {
            if (labelText !== '') {
                labelText += '\n';
            }
            labelText += ('wait: ' + waypoint.wait).slice(0, 10);
        }
        if (labelText !== '') {
             labelCollection.add({
                show: true,
                scale: 0.5,
                showBackground: true,
                horizontalOrigin: HorizontalOrigin.LEFT,
                verticalOrigin: VerticalOrigin.TOP,
                pixelOffset: new Cartesian2(10, 10),
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
                position:waypoint.position,
                text: labelText
            });
        }

        if (waypoint === selectedWaypoint) {
            pointCollection.add({
                pixelSize: 10,
                color: Color.LIGHTGREEN,
                position: waypoint.position,
                show: true,
                disableDepthTestDistance: Number.POSITIVE_INFINITY
            });
        } else {
            pointCollection.add({
                pixelSize: 10,
                color: Color.YELLOW,
                position: waypoint.position,
                show: true,
                disableDepthTestDistance: Number.POSITIVE_INFINITY
            });
        }
    }
}

function handlePick(cartesian) {
    // Check if this point is close to any selected waypoints
    // If so, select the waypoint instead.
    var nearWaypoint;
    var waypointCount = waypoints.length;
    for (var i = 0; i < waypointCount; i++) {
        var waypointPosition = waypoints[i].position;
        if (Cartesian3.distance(waypointPosition, cartesian) < 0.5) {
            nearWaypoint = waypoints[i];
            // If near selected waypoint, move it
            if (nearWaypoint === selectedWaypoint) {
                Cartesian3.clone(cartesian, selectedWaypoint.position);
            }
            break;
        }
    }

    if (defined(nearWaypoint)) {
        selectedWaypoint = nearWaypoint;
    } else {
        selectedWaypoint = new Waypoint(cartesian);
        waypoints.push(selectedWaypoint);
    }
}

Sandcastle.addToolbarButton('Delete', function() {
    if (defined(selectedWaypoint)) {
        // TODO: bad, write something better
        var waypointCount = waypoints.length;
        var oldWaypoints = waypoints;
        waypoints = [];
        for (var i = 0; i < waypointCount; i++) {
            if (oldWaypoints[i] === selectedWaypoint) {
                continue;
            }
            waypoints.push(oldWaypoints[i]);
        }
        selectedWaypoint = undefined;
        updateGraphics();
    }
});

Sandcastle.addToolbarButton('Clear Time/Wait', function() {
    if (defined(selectedWaypoint)) {
        selectedWaypoint.time = 0.0;
        selectedWaypoint.wait = 0.0;
        updateGraphics();
    }
});

Sandcastle.addToggleButton('Time', false, function(checked) {
    adjustingTime = checked;
    scene.screenSpaceCameraController.enableInputs = !(adjustingTime || adjustingWait);
});

Sandcastle.addToggleButton('Wait', false, function(checked) {
    adjustingWait = checked;
    scene.screenSpaceCameraController.enableInputs = !(adjustingTime || adjustingWait);
});

Sandcastle.addToolbarButton('run', function() {
    //console.log(JSON.stringify(waypoints));

    viewer.dataSources.removeAll();
    var czml = generateCzml(waypoints);
    //console.log(JSON.stringify(czml));
    var dataSourcePromise = viewer.dataSources.add(Cesium.CzmlDataSource.load(czml));

    dataSourcePromise.then(function(dataSource){
        //viewer.trackedEntity = dataSource.entities.getById('cesium car');
    }).otherwise(function(error){
        window.alert(error);
    });
});

var czmlCars = [{
        "id": "document",
        "name": "CZML Models",
        "version": "1.0",
        "clock": {
            "interval": "2017-02-15T09:00:00Z/2017-02-15T09:01:00Z",
            "currentTime": "2017-02-15T09:00:00Z",
            "multiplier": 1,
            "range": "LOOP_STOP",
            "step": "SYSTEM_CLOCK_MULTIPLIER"
        }
    },
    {"id":"cesium car","model":{"gltf":"../../SampleData/CesiumCar/fav_v11b_sp_transformed.gltf","scale":1,"minimumPixelSize":4},"position":{"interpolationAlgorithm":"LINEAR","forwardExtrapolationType":"HOLD","interpolationDegree":1,"epoch":"2017-02-15T09:00:00Z","cartesian":[0,3792967.6836375105,-415060.9181080394,5093812.460230941,1.5177843386298224,3792972.185786497,-415061.91482213483,5093808.907529211,3.1782307632218814,3792977.172087481,-415062.96129590773,5093805.087138842,4.670245751165555,3792981.705373191,-415064.0019305163,5093801.753965802,6.41409691629956,3792986.987568279,-415064.98310744116,5093797.770780724,6.863106576818552,3792988.2127790633,-415065.2295285154,5093796.820769099,7.35026215563535,3792989.5971585494,-415065.199817412,5093795.829047606,8.012454405973436,3792991.378939251,-415064.4038423159,5093794.583378097,8.580661372893129,3792992.931547506,-415063.76762447937,5093793.5198363485,9.288733055384176,3792994.693392729,-415062.48728721065,5093792.342930825,10.092882581647793,3792996.5336323017,-415060.7999380506,5093791.050331984,11.092511013215859,3792998.246759463,-415057.93119214196,5093790.025654041,11.49304507396959,3792999.330934253,-415053.9020907986,5093789.491834522,11.868740803220867,3793000.263907426,-415050.0849158003,5093789.136429935,12.283111741195944,3793000.9701001407,-415045.7947208121,5093788.954189766,12.73950601333144,3793001.97098171,-415041.1253368966,5093788.543483668,12.90814992602749,3793002.8896284224,-415039.7021013715,5093788.026462868,13.028538538341504,3793003.651870453,-415038.8247839058,5093787.528641937,13.084270160721612,3793003.8534968486,-415038.2875727137,5093787.413216948,13.142116294922374,3793003.912105323,-415037.6829041396,5093787.41427764,13.246289660855494,3793004.0917669297,-415036.6041560179,5093787.3836956285,13.996204468470733,3793005.317983328,-415028.83067637717,5093787.075144971,14.740088105726876,3793006.5275127725,-415021.1198940717,5093786.738988967]},"orientation":{"interpolationAlgorithm":"LINEAR","forwardExtrapolationType":"HOLD","interpolationDegree":1,"epoch":"2017-02-15T09:00:00Z","unitQuaternion":[0,0.004358483834773125,0.32364411066386456,-0.09241670843060154,0.9416446491400625,1.5177843386298224,0.004979123042618289,0.31722523250910695,-0.08869471114060606,0.9441803897608518,3.1782307632218814,0.0013904988731928262,0.3075269570258127,-0.09650755693195666,0.946631675294226,4.670245751165555,0.0076020776411821886,0.31415172103968697,-0.08006805015689858,0.9459598363183357,6.41409691629956,0.006352785477068178,0.32012759093033677,-0.08534160688262109,0.943501339573248,6.863106576818552,0.03388025023227151,0.30592862217391803,-0.0017266411941509428,0.9514498544269968,7.35026215563535,0.08600442300094883,0.30151140568820867,0.1558372781268948,0.9367010484728813,8.012454405973436,0.08305831934159089,0.2974494629185585,0.14404509532022086,0.9401468731596143,8.580661372893129,0.11576280718278874,0.2899018191203422,0.24517584626061487,0.9178478698315251,9.288733055384176,0.1264080569763877,0.29614005908949015,0.291597504073225,0.9007180269941272,10.092882581647793,0.17436148327146933,0.26237323692047776,0.4313608391472094,0.8453911426963612,11.092511013215859,0.21019955890562114,0.23723176774020363,0.5611149310350689,0.7646484603922579,11.49304507396959,0.2194520835884313,0.22671250942310595,0.5747792396169163,0.7550304939439029,11.868740803220867,0.2275584071609186,0.21923203378123612,0.6089321023246691,0.7275686781692757,12.283111741195944,0.2184575554613007,0.2289445966523792,0.5858116523511107,0.746113514215641,12.73950601333144,0.17472470048108152,0.25655061905020127,0.4181379267843385,0.853705882076052,12.90814992602749,0.14643746663194146,0.2803432000181052,0.34636115520193206,0.8831747894597145,13.028538538341504,0.1957310753990211,0.25040591169237336,0.5148338826450469,0.7961986553576187,13.084270160721612,0.2344785662029824,0.2117315655687568,0.6379126684081204,0.7023225566772209,13.142116294922374,0.23205589122908193,0.21398931446298136,0.6099990953508785,0.7268147909286448,13.246289660855494,0.22775653365283663,0.2191018237041904,0.6116745580545931,0.7252417440113746,13.996204468470733,0.22647990687717676,0.2205942213655097,0.6114952031129305,0.7253403737907643]}}
];

Sandcastle.addToolbarButton('pop packet', function() {
    if (czmlCars.length > 1) {
        czmlCars.pop();
        viewer.dataSources.removeAll();
        viewer.dataSources.add(Cesium.CzmlDataSource.load(czmlCars));
    }
});

Sandcastle.addToolbarButton('log czml', function() {
    console.log(JSON.stringify(czmlCars));
});

function generateCzml(originalWaypoints) {
    // duplicate waypoints to mimic pauses - that's how it'll work in the CZML
    var originalWaypointCount = originalWaypoints.length;
    var waypoints = [];
    var waypoint;
    for (var i = 0; i < originalWaypointCount; i++) {
        waypoint = originalWaypoints[i];
        var newWaypoint = new Waypoint(waypoint.position);
        newWaypoint.time = waypoint.time;
        waypoints.push(newWaypoint);
        if (waypoint.wait > 0.0) {
            newWaypoint = new Waypoint(waypoint.position);
            newWaypoint.time = waypoint.wait;
            waypoints.push(newWaypoint);
        }
    }

    // compute timestamps for each waypoint
    var waypointCount = waypoints.length;
    var firstWaypoint = waypoints[0];
    var accumulatedTime = firstWaypoint.time;

    var positionTimestamps = [accumulatedTime];
    var positions = [firstWaypoint.position];
    var interpStartIndex = -1;
    // for each waypoint...
    // - if the waypoint doesn't have a time...
    //   - add to interp
    // - if the waypoint has a time
    //   - if interp is empty, add to accumulatedTime and append
    //   - otherwise, interpolate times and add all interp
    for (i = 1; i < waypointCount; i++) {
        waypoint = waypoints[i];
        if (waypoint.time === 0.0) {
            if (interpStartIndex === -1) {
                interpStartIndex = i;
            }
            continue;
        }
        if (interpStartIndex === -1) {
            accumulatedTime += waypoint.time;
            positions.push(waypoint.position);
            positionTimestamps.push(accumulatedTime);
        } else {
            // Interpolate - give each waypoint a proportion of the waypoint time based on
            // its length relative to the full polyline length.
            // Each waypoint is considered to be the "end" of a segment
            var polylineLength = 0.0;
            for (var j = interpStartIndex; j <= i; j++) {
                polylineLength += Cartesian3.distance(waypoints[j].position, waypoints[j - 1].position);
            }
            for (j = interpStartIndex; j <= i; j++) {
                var proportion = Cartesian3.distance(waypoints[j].position, waypoints[j - 1].position) / polylineLength;
                accumulatedTime += waypoint.time * proportion;
                positions.push(waypoints[j].position);
                positionTimestamps.push(accumulatedTime);
            }
            interpStartIndex = -1;
        }
    }

    var orientationTimestamps = [];
    var orientations = [];
    // Compute orientations. For each waypoint, point to the next waypoint, unless it's very nearby.
    for (i = 0; i < waypointCount - 1; i++) {
        var pos = positions[i];
        var nextPos = positions[i + 1];
        if (Cartesian3.distance(pos, nextPos) < 0.1) { // usually, a wait
            // duplicate previous orientation to imitate a wait. TODO this is kind of hacky...
            orientations.push(orientations[orientations.length - 1]);
            orientationTimestamps.push(positionTimestamps[i]);
            i++;
            orientations.push(orientations[orientations.length - 1]);
            orientationTimestamps.push(positionTimestamps[i]);
            continue;
        }
        // compute rotation to X-forward
        var targetForward = Cartesian3.normalize(Cartesian3.subtract(nextPos, pos, new Cartesian3()), new Cartesian3());
        var rotationAxis = Cartesian3.cross(Cartesian3.UNIT_X, targetForward, new Cartesian3());
        var angle = Math.acos(Cartesian3.dot(Cartesian3.UNIT_X, targetForward));
        var rotateToForward = Quaternion.fromAxisAngle(rotationAxis, angle);

        // compute target Y-up using forward and direction from origin
        var out = Cartesian3.normalize(pos, new Cartesian3());
        var rightAxis = Cartesian3.cross(targetForward, out, new Cartesian3());
        var targetForwardToUp = Quaternion.fromAxisAngle(rightAxis, CesiumMath.PI * 0.5);
        var targetUp = Matrix3.multiplyByVector(Matrix3.fromQuaternion(targetForwardToUp), targetForward, new Cartesian3());

        var currentUp = Matrix3.multiplyByVector(Matrix3.fromQuaternion(rotateToForward), Cartesian3.UNIT_Z, new Cartesian3());
        angle = Math.acos(Cartesian3.dot(targetUp, currentUp));
        // sign of angle is based on which side of targetUp the currentUp is on
        var sign = Cartesian3.cross(currentUp, targetUp, new Cartesian3());
        if (Cartesian3.dot(sign, targetForward) < 0) {
            angle = -angle;
        }

        var rotateToUp = Quaternion.fromAxisAngle(targetForward, angle);

        // compose quaternions
        orientations.push(Quaternion.multiply(rotateToUp, rotateToForward, new Quaternion()));
        orientationTimestamps.push(positionTimestamps[i]);
    }

    // generate czml!
    var cartesians = [];
    for (i = 0; i < waypointCount; i++) {
        cartesians.push(positionTimestamps[i]);
        var position = positions[i];
        cartesians.push(position.x);
        cartesians.push(position.y);
        cartesians.push(position.z);
    }

    var quaternions = [];
    var orientationCount = orientations.length;
    for (i = 0; i < orientationCount; i++) {
        quaternions.push(orientationTimestamps[i]);
        var quaternion = orientations[i];
        quaternions.push(quaternion.x);
        quaternions.push(quaternion.y);
        quaternions.push(quaternion.z);
        quaternions.push(quaternion.w);
    }

    var packet = {
        "id": "cesium car " + (czmlCars.length + 1),
            "model": {
                "gltf": "../../SampleData/CesiumCar/fav_v11b_sp_transformed.gltf",
                "scale": 1.0,
                "minimumPixelSize": 4
            },
            "position": {
                "interpolationAlgorithm": "LINEAR",
                "forwardExtrapolationType": "HOLD",
                "interpolationDegree": 1,
                "epoch": "2017-02-15T09:00:00Z",
                "cartesian": cartesians
            },
            "orientation": {
                "interpolationAlgorithm": "LINEAR",
                "forwardExtrapolationType": "HOLD",
                "interpolationDegree": 1,
                "epoch": "2017-02-15T09:00:00Z",
                "unitQuaternion": quaternions
            }
    };
    console.log(JSON.stringify(packet));

    czmlCars.push(packet);
    return czmlCars;
}

Sandcastle.addToolbarButton('clear all points', function() {
    waypoints = [];
    updateGraphics();
});

/** end czml path generator **///Sandcastle_End
    Sandcastle.finishedLoading();
}
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}
</script>
</body>
</html>
